<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Model</title>
	<style>
		#canvas {
			border: 1px solid black;
		}

		body { 
			margin: 10px; 
		}

		#container {
			width: 1000px; 
			height: 700px; 
			/background-color: green; 
		}

		#container {
			width: calc(100vw - 20px); 
			height: calc(100vh - 20px); 
			/background-color: green; 
		}

	</style>
	<script src="three.js"></script>
	<script src="OrbitControls.js"></script>
</head>
<body>
	<div id="container"></div>
	<script>


var container, scene, camera, renderer, controls;
var ArrayDeltaY = [];


function createModelArrayY (number) {
	for (var i = 0; i < number+1; i++) {
		ArrayDeltaY[i] = (0.5 + (number - i)/number * 0.5);
	}
}


function init (){
	container = document.getElementById( 'container' );
	scene = new THREE.Scene();
	scene.background = new THREE.Color( 0xffffff );
	camera = new THREE.PerspectiveCamera( 75, container.offsetWidth/container.offsetHeight, 0.1, 10000 );
	renderer = new THREE.WebGLRenderer();
	renderer.setSize( container.offsetWidth, container.offsetHeight );
	container.appendChild( renderer.domElement );
	controls = new THREE.OrbitControls( camera, renderer.domElement );
}

init();

createArrayY (-minX+maxX);


var positions, colors, time;
var lines = 1000;
var buffer_geometry;

var initPosition = [];

var minX, maxX, lendthFiber, sizeY, sizeZ, timeSpeed;

minX = 0;
maxX = 1000;
lendthFiber = 300;
sizeY = 200;
sizeZ = 200;
timeSpeed = 5;

camera.position.x = (minX+maxX)/2;
camera.position.z = 1500;







function createGeomData() {
    
    for ( var i = 0; i < lines; i ++ ) {

        positions[ i * 6 + 0 ] = (Math.random() * (-minX + maxX - lendthFiber/2)) - ((-minX + maxX) / 2);
        positions[ i * 6 + 1 ] = Math.random() * sizeY * 2 - sizeY;
        positions[ i * 6 + 2 ] = Math.random() * sizeZ * 2 - sizeZ;
        positions[ i * 6 + 3 ] = positions[ i * 6 + 0 ] + Math.random() * lendthFiber;
        positions[ i * 6 + 4 ] =  positions[ i * 6 + 1 ];
        positions[ i * 6 + 5 ] =  positions[ i * 6 + 2 ];

        //initPosition[ i * 2 + 0 ] = positions[ i * 6 + 1 ];
        //initPosition[ i * 2 + 1 ] = positions[ i * 6 + 4 ];

        /*colors[ i * 6 + 0 ] = 0;
        colors[ i * 6 + 1 ] = 0;
        colors[ i * 6 + 2 ] = 0;
        colors[ i * 6 + 3 ] = 0;
        colors[ i * 6 + 4 ] = 0;
        colors[ i * 6 + 5 ] = 0;*/
    }

    time = new Date();
    
}


function updateGeomData() {

	let timeN =new Date();
	var x = (timeN - time) / timeSpeed;
	time = timeN;
    
    for ( var i = 0; i < lines; i ++ ) {

        positions[ i * 6 + 0 ] = positions[ i * 6 + 0 ] + x;
        positions[ i * 6 + 3 ] = positions[ i * 6 + 3 ] + x;

        if (positions[ i * 6 + 3 ] >= maxX) {
       	positions[ i * 6 + 0 ] = minX;
        positions[ i * 6 + 1 ] = Math.random() * sizeY * 2 - sizeY;
        positions[ i * 6 + 2 ] = Math.random() * sizeZ * 2 - sizeZ;
        positions[ i * 6 + 3 ] = minX + Math.random() * lendthFiber;
        positions[ i * 6 + 4 ] =  positions[ i * 6 + 1 ];
        positions[ i * 6 + 5 ] =  positions[ i * 6 + 2 ];
        }

        //positions[ i * 6 + 1 ] = initPosition[ i * 2 + 0 ] * ArrayDeltaY[~~(positions[ i * 6 + 1 ])];
        //positions[ i * 6 + 4 ] = initPosition[ i * 2 + 1 ] * ArrayDeltaY[~~(positions[ i * 6 + 4 ])];

    }
    
}


function add_lines_buffer_geom() {

    buffer_geometry = new THREE.BufferGeometry();

    buffer_geometry.dynamic = true;

    buffer_geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array(lines * 6), 3 ));

    //buffer_geometry.addAttribute( 'color', new THREE.BufferAttribute( new Float32Array(lines * 6), 3 ));

    //var material = new THREE.LineBasicMaterial({ vertexColors: true });

    positions = buffer_geometry.attributes.position.array;
    //colors = buffer_geometry.attributes.color.array;

    createGeomData();

    //buffer_geometry.computeBoundingSphere();

    var material = new THREE.LineBasicMaterial({ color: 0x0, opacity: 0.7, transparent: true });

    var buffer_mesh = new THREE.LineSegments( buffer_geometry, material );
    scene.add( buffer_mesh );
}

function init1() {

    


    add_lines_buffer_geom();

    animate();
}

function animate() {

    requestAnimationFrame(animate);

    updateGeomData();

    buffer_geometry.attributes.position.needsUpdate = true;
    //buffer_geometry.attributes.color.needsUpdate = true;

    //buffer_geometry.computeBoundingSphere();

    renderer.render(scene, camera);
}



init1();


/*
var material = new THREE.LineBasicMaterial({ color: 0x0, opacity: 0.5, transparent: true });

/*
var n = 1;
var minLengthFiber = 50;

Line = new Array(n);

for (var i = 0; i < n; i++) {

	var startPointX = -5;
	var startPointY = Math.random() * 2 - 1; // от -1 до 1
	var startPointZ = Math.random() * 2 - 1;

	for (;;){
		nextPointX = Math.random() * 2 - 0.4;
		nextPointY = Math.random() * 2 - 1;
		nextPointZ = Math.random() * 2 - 1;

		let lengthFiber = ;
		if ( lengthFiber >= minLengthFiber ) break;
	}

	
	var A = Array(10);
	for (var j = 0; j < 10; j++) {
		var x = (j-Math.random()*10)-2;
		var fi = Math.random()*2*Math.PI;
		var ro = Math.random();
		var y = ro*Math.sin(fi);
		var z = ro*Math.cos(fi);
		A[j] =new THREE.Vector3( x, y, z );
	};

	var curve = new THREE.CatmullRomCurve3( A );
	var points = curve.getPoints( 100 );
	var geometry = new THREE.BufferGeometry().setFromPoints( points );

	Line[i] = new THREE.Line( geometry, material );
	scene.add(Line[i]);

};

*/

//scene.add(new THREE.Mesh(new THREE.PlaneGeometry(5,7,1),new THREE.MeshBasicMaterial({color:0xffff00,side:THREE.DoubleSide})));



/*
class Fiber {
	constructor () {
		this.firstPointX = Math.random()*18-10
		this.firstPointY = Math.random() * 2 - 1
		this.firstPointZ = Math.random() * 2 - 1
		this.lastPointX = this.firstPointX+2
		this.lastPointY = this.firstPointY
		this.lastPointZ = this.firstPointZ

		this.time = new Date ()
	}

	create () {
		this.firstPointX = -10
		this.firstPointY = Math.random() * 2 - 1
		this.firstPointZ = Math.random() * 2 - 1
		this.lastPointX = this.firstPointX+2
		this.lastPointY = this.firstPointY
		this.lastPointZ = this.firstPointZ

		this.time = new Date ()
	}

	check () {
		if (this.lastPointX >= 10) this.remove ()
	}

	remove () {
		this.create ()
	}

	shift (x) {
		this.firstPointX = this.firstPointX + x
		this.lastPointX = this.lastPointX + x
	}

	movement (time) {
		this.shift ((time - this.time)/500)
		this.time = time
		this.check ()
	}

	createGeometry () {

		//let A = Array(2);
		//A[0] =new THREE.Vector3( this.firstPointX, this.firstPointY, this.firstPointZ );
		//A[1] =new THREE.Vector3( this.lastPointX, this.lastPointY, this.lastPointZ );

		//let curve = new THREE.CatmullRomCurve3( A );
		//let points = curve.getPoints( 5 );
		//let geometry = new THREE.BufferGeometry().setFromPoints( points );

		let geometry = new THREE.Geometry();
			geometry.vertices = [
			new THREE.Vector3( this.firstPointX, this.firstPointY, this.firstPointZ ),
			new THREE.Vector3( this.lastPointX, this.lastPointY, this.lastPointZ )
		];

		//let Line = new THREE.Line( geometry, material );

		//return Line;
		return geometry;
	}


}



var namber = 100;
var Line = new Array(namber);
var LineGeometry = new Array(namber);
var fibers = [];

function Tape () {
	for (var i = 0; i < namber; i++) {
		fibers[i]  = new Fiber();
		LineGeometry[i] = fibers[i].createGeometry ();
		Line[i] = new THREE.Line( LineGeometry[i], material );
		scene.add(Line[i]);
	}
}


function clear () {
	for (var i = 0; i < namber; i++) {
		scene.remove(Line[i]);
		scene.dispose();
	}
}

function movementFibers () {
	//clear ();

	for (var i = 0; i < namber; i++) {
		fibers[i].movement(new Date());

		LineGeometry[i] = fibers[i].createGeometry ();

		//Line[i].vertices = LineGeometry[i];
		LineGeometry[i].verticesNeedUpdate = true;
		
		//scene.add(Line[i]);

	}
}

//Tape ();


*/
/*
			var geometry = new THREE.BoxGeometry( 1, 1, 1 );
			var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
			var cube = new THREE.Mesh( geometry, material );
			scene.add( cube );
*/
/*
var material = new THREE.LineBasicMaterial({
	color: 0x0000ff
});

var geometry = new THREE.Geometry();
geometry.vertices.push(
	new THREE.Vector3( -10, 0, 0 ),
	new THREE.Vector3( 0, 10, 0 ),
	new THREE.Vector3( 10, 0, 0 )
);

var line = new THREE.Line( geometry, material );
scene.add( line );
scene.remove( line );

geometry = new THREE.Geometry();
geometry.vertices.push(
	new THREE.Vector3( 0, 0, 0 ),
	new THREE.Vector3( 0, 10, 0 ),
	new THREE.Vector3( 10, 0, 0 )
);
line.verticesNeedUpdate = true;
//line = new THREE.Line( geometry, material );
scene.add( line );


var animate = function () {
	requestAnimationFrame( animate );
	//movementFibers ();
	renderer.render( scene, camera );
};

animate();

*/


/*
function updateGeomData() {


    
    var radius = 280;
    
    for ( var i = 0; i < lines; i ++ ) {

        var lat = Math.random()*180 - 90;
        var lng = Math.random()*360 - 180;

        var phi = (90.0 - lat) * Math.PI / 180.0;
        var theta = (360.0 - lng) * Math.PI / 180.0;
        var x = radius * Math.sin(phi) * Math.cos(theta);
        var y = radius * Math.cos(phi);
        var z = radius * Math.sin(phi) * Math.sin(theta);

        positions[ i * 6 + 0 ] = 0;
        positions[ i * 6 + 1 ] = 0;
        positions[ i * 6 + 2 ] = 0;
        positions[ i * 6 + 3 ] = x;
        positions[ i * 6 + 4 ] = y;
        positions[ i * 6 + 5 ] = z;

        colors[ i * 6 + 0 ] = 0;
        colors[ i * 6 + 1 ] = 0;
        colors[ i * 6 + 2 ] = 0;
        colors[ i * 6 + 3 ] = ( x / radius ) + 0.5;
        colors[ i * 6 + 4 ] = ( y / radius ) + 0.5;
        colors[ i * 6 + 5 ] = ( z / radius ) + 0.5;
    }
    
}
*/
	</script>
</body>
</html>