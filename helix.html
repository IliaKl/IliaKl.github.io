<html><head><title>ik</title>
<script type="text/javascript" src="three.js"></script>
<script type="text/javascript" src="OrbitControls.js"></script>
<style>
body { margin: 0; }
canvas { width: 100%; height: 100% }
</style>
</head>

<body><script>
var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 10, 10000 );
camera.position.set( 0, 0, -100 );
var scene = new THREE.Scene();
scene.background = new THREE.Color( 0xaaaaaa );
var light0 = new THREE.AmbientLight( 0xffffff, 1 ); 
scene.add( light0 );
var light1 = new THREE.PointLight( 0xffffff, 1, 100 ); 
light1.position.set( 50, 50, 0 );
scene.add( light1 );


var material = new THREE.MeshPhongMaterial( { color: 0xdddddd } );


var h = 102.5;
var dt = 8;
var t = 0.6;

/*
var Axe1 = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, h, 8, 1 ), material );
scene.add( Axe1 );

var Axe2 = new THREE.Mesh( new THREE.CylinderGeometry( dt/2, dt/2, h, 32, 1 ), material );
scene.add( Axe2 );

var Axe3 = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, h, 8, 1 ), material );
Axe3.rotation.set( 0, 0, -Math.PI/6 );
scene.add( Axe3 );
*/

function CustomSinCurve( scale ) {

  THREE.Curve.call( this );

  this.scale = ( scale === undefined ) ? 1 : scale;

}

CustomSinCurve.prototype = Object.create( THREE.Curve.prototype );
CustomSinCurve.prototype.constructor = CustomSinCurve;

CustomSinCurve.prototype.getPoint = function ( t ) {
  
  var b = 3/2*a;

  var s = (t - 0.5) * (h/b);
  var tx = a*Math.cos(s);
  var ty = b*s;
  var tz = a*Math.sin(s);

  return new THREE.Vector3( tx, ty, tz ).multiplyScalar( this.scale );

};

var HelixArray = [];
var Helix = new THREE.Group();

var a = dt/2+t/2;
var path1 = new CustomSinCurve( 1 );
var mesh = new THREE.Mesh( new THREE.TubeGeometry( path1, 100, t/2, 8, false ), material );

for (var i = 1; i < 7; i++){

  HelixArray[i] = mesh.clone();
  HelixArray[i].rotation.set( 0, i/3*Math.PI, 0 );
  Helix.add( HelixArray[i] );
}

var a = -(dt/2+1.5*t);
var path2 = new CustomSinCurve( 1 );
var mesh = new THREE.Mesh( new THREE.TubeGeometry( path2, 100, t/2, 8, false ), material );

for (var i = 7; i < 13; i++){

  HelixArray[i] = mesh.clone();
  HelixArray[i].rotation.set( 0, i/3*Math.PI, 0 );
  Helix.add( HelixArray[i] );
}

scene.add( Helix );


var TopT = new THREE.Mesh( new THREE.TorusGeometry( dt/2+t/2, t/2, 8, 64 ), material );
TopT.position.set( 0, h/2, 0 ); 
TopT.rotation.set(Math.PI/2, 0, 0);
scene.add( TopT );

var BottomT = new THREE.Mesh( new THREE.TorusGeometry( dt/2+t/2, t/2, 8, 64 ), material );
BottomT.position.set( 0, -h/2, 0 ); 
BottomT.rotation.set(Math.PI/2, 0, 0);
scene.add( BottomT );

/*
var Helix1 = function () {
;
var helix = new THREE.Curve();
helix.getPoint = function(t) {
   var s = (t - 0.5) * 6.3*Math.PI;
         // As t ranges from 0 to 1, s ranges from -6*PI to 6*PI


   return new THREE.Vector3(
        4*Math.cos(s),
        5*s,
        4*Math.sin(s)
   );
}


var geometry = new THREE.TubeGeometry( helix, 100, 0.5, 12, false );
var material = new THREE.MeshBasicMaterial( { color: 0xdddddd } );
var mesh = new THREE.Mesh( geometry, material );
scene.add( mesh );

/*
var Helix3 = Helix1( 4, 5, 100, 8.3 );
Helix3.position.set( 0, 0, 0 );
scene.add( Helix3 );
//scene.add( Platform );
/*
var planeP = new THREE.Mesh( new THREE.PlaneGeometry( 1000, 1000 ), new THREE.MeshPhongMaterial( {color: 0x555555} ) );
planeP.position.set( 0, -65, 0 ); planeP.rotation.set(-Math.PI/2, 0, 0);
scene.add( planeP );
*/
/*
var Box = new THREE.Mesh( new THREE.BoxGeometry( 10, 180, 10 ), new THREE.MeshPhongMaterial( {color: 0x777777} ) );
Box.position.set( 90, 25, 0 ); //planeP.rotation.set(-Math.PI/2, 0, 0);
scene.add( Box );
*/
/*
var CentrAxis = new THREE.Mesh( new THREE.CylinderGeometry( 5, 5, 130, 12, 1 ), new THREE.MeshPhongMaterial( {color: 0xdddddd} ) );
CentrAxis.position.set( 0, 0, 0 ); //CentrAxis.rotation.set(-Math.PI/2, 0, 0);
//scene.add( CentrAxis );

var TopPlatform = new THREE.Mesh( new THREE.CylinderGeometry( 12.5, 12.5, 1, 36, 1 ), new THREE.MeshPhongMaterial( {color: 0xdddddd} ) );
var h0 = 65;
TopPlatform.position.set( 0, h0, 0 );
scene.add( TopPlatform );

var MidPlatform = new THREE.Mesh( new THREE.CylinderGeometry( 8.75, 8.75, 1, 36, 1 ), new THREE.MeshPhongMaterial( {color: 0xdddddd} ) );

var MidPlatform1 = MidPlatform.clone();
var MidPlatform2 = MidPlatform.clone();
var MidPlatform3 = MidPlatform.clone();

var ro1 = 17.5;
var h1 = h0 - 27.5;
var p1 = Math.PI/6;
MidPlatform1.position.set( ro1 * Math.cos( 0/3*Math.PI+p1 ), h1, ro1 * Math.sin( 0/3*Math.PI+p1 ) );
MidPlatform2.position.set( ro1 * Math.cos( 2/3*Math.PI+p1 ), h1, ro1 * Math.sin( 2/3*Math.PI+p1 ) );
MidPlatform3.position.set( ro1 * Math.cos( 4/3*Math.PI+p1 ), h1, ro1 * Math.sin( 4/3*Math.PI+p1 ) );

scene.add( MidPlatform1, MidPlatform2, MidPlatform3 );



var Mid1Platform = new THREE.Mesh( new THREE.CylinderGeometry( 10, 10, 1, 36, 1 ), new THREE.MeshPhongMaterial( {color: 0xdddddd} ) );

var Mid1Platform1 = Mid1Platform.clone();
var Mid1Platform2 = Mid1Platform.clone();
var Mid1Platform3 = Mid1Platform.clone();
var Mid1Platform4 = Mid1Platform.clone();
var Mid1Platform5 = Mid1Platform.clone();
var Mid1Platform6 = Mid1Platform.clone();

var ro2 = 30;
var h2 = h1-37.5;
Mid1Platform1.position.set( ro2 * Math.cos( 0/3*Math.PI ), h2, ro2 * Math.sin( 0/3*Math.PI ) );
Mid1Platform2.position.set( ro2 * Math.cos( 1/3*Math.PI ), h2, ro2 * Math.sin( 1/3*Math.PI ) );
Mid1Platform3.position.set( ro2 * Math.cos( 2/3*Math.PI ), h2, ro2 * Math.sin( 2/3*Math.PI ) );
Mid1Platform4.position.set( ro2 * Math.cos( 3/3*Math.PI ), h2, ro2 * Math.sin( 3/3*Math.PI ) );
Mid1Platform5.position.set( ro2 * Math.cos( 4/3*Math.PI ), h2, ro2 * Math.sin( 4/3*Math.PI ) );
Mid1Platform6.position.set( ro2 * Math.cos( 5/3*Math.PI ), h2, ro2 * Math.sin( 5/3*Math.PI ) );

scene.add( Mid1Platform1, Mid1Platform2, Mid1Platform3, Mid1Platform4, Mid1Platform5, Mid1Platform6 );




var BottomPlatform = new THREE.Mesh( new THREE.CylinderGeometry( 15, 15, 1, 36, 1 ), new THREE.MeshPhongMaterial( {color: 0xdddddd} ) );

var BottomPlatform1 = BottomPlatform.clone();
var BottomPlatform2 = BottomPlatform.clone();
var BottomPlatform3 = BottomPlatform.clone();
var BottomPlatform4 = BottomPlatform.clone();
var BottomPlatform5 = BottomPlatform.clone();
var BottomPlatform6 = BottomPlatform.clone();

var ro3 = 30;
var h3 = h2-47.5;
var p = Math.PI/6;
BottomPlatform1.position.set( ro3 * Math.cos( 0/3*Math.PI+p ), h3, ro3 * Math.sin( 0/3*Math.PI+p ) );
BottomPlatform2.position.set( ro3 * Math.cos( 1/3*Math.PI+p ), h3, ro3 * Math.sin( 1/3*Math.PI+p ) );
BottomPlatform3.position.set( ro3 * Math.cos( 2/3*Math.PI+p ), h3, ro3 * Math.sin( 2/3*Math.PI+p ) );
BottomPlatform4.position.set( ro3 * Math.cos( 3/3*Math.PI+p ), h3, ro3 * Math.sin( 3/3*Math.PI+p ) );
BottomPlatform5.position.set( ro3 * Math.cos( 4/3*Math.PI+p ), h3, ro3 * Math.sin( 4/3*Math.PI+p ) );
BottomPlatform6.position.set( ro3 * Math.cos( 5/3*Math.PI+p ), h3, ro3 * Math.sin( 5/3*Math.PI+p ) );

scene.add( BottomPlatform1, BottomPlatform2, BottomPlatform3, BottomPlatform4, BottomPlatform5, BottomPlatform6 );

var Bottom1Platform = new THREE.Mesh( new THREE.CylinderGeometry( 35, 35, 1, 36, 1 ), new THREE.MeshPhongMaterial( {color: 0xdddddd} ) );
Bottom1Platform.position.set( 0, h3, 0 );
scene.add( Bottom1Platform );

var Bottom2Platform = new THREE.Mesh( new THREE.CylinderGeometry( 35, 35, 1, 36, 1 ), new THREE.MeshPhongMaterial( {color: 0xdddddd} ) );
Bottom2Platform.position.set( 0, h3-17.5, 0 );
scene.add( Bottom2Platform );



var Helix1 = function ( a, b, hx, pi1) {
         var a = a;
         var b = b;
         var pi1 = pi1;
var helix = new THREE.Curve();
helix.getPoint = function(t) {
   var s = (t - 0.5) * pi1*Math.PI;
         // As t ranges from 0 to 1, s ranges from -6*PI to 6*PI

         a = a;
         b = b;
   return new THREE.Vector3(
        a*Math.cos(s),
        b*s,
        a*Math.sin(s)
   );
}

var geometry = new THREE.TubeGeometry( helix, hx, 0.5, 12, false );
var material = new THREE.MeshBasicMaterial( { color: 0xdddddd } );
var mesh = new THREE.Mesh( geometry, material );

var mesh1 = mesh.clone();
var mesh2 = mesh.clone();
var mesh3 = mesh.clone();
var mesh4 = mesh.clone();
var mesh5 = mesh.clone();
var mesh6 = mesh.clone();

mesh1.rotation.set(0, 0/3*Math.PI, 0);
mesh2.rotation.set(0, 1/3*Math.PI, 0);
mesh3.rotation.set(0, 2/3*Math.PI, 0);
mesh4.rotation.set(0, 3/3*Math.PI, 0);
mesh5.rotation.set(0, 4/3*Math.PI, 0);
mesh6.rotation.set(0, 5/3*Math.PI, 0);

var GroupHelix = new THREE.Group();

GroupHelix.add( 
	mesh1, 
	mesh2, 
	mesh3, 
	mesh4, 
	mesh5, 
	mesh6 
	);




var helix2 = new THREE.Curve();
         var a = a;
         var b = b;
         var pi1 = pi1;
helix2.getPoint = function(t) {
   var s = (t - 0.5) * pi1*Math.PI;
         // As t ranges from 0 to 1, s ranges from -6*PI to 6*PI

         a = a;
         b = b;
   return new THREE.Vector3(
        a*Math.sin(s),
        b*s,
        a*Math.cos(s)
   );
}

var geometry2 = new THREE.TubeGeometry( helix2, hx, 0.5, 12, false );
var material2 = new THREE.MeshBasicMaterial( { color: 0xdddddd } );
var mesh2 = new THREE.Mesh( geometry2, material2 );

var mesh21 = mesh2.clone();
var mesh22 = mesh2.clone();
var mesh23 = mesh2.clone();
var mesh24 = mesh2.clone();
var mesh25 = mesh2.clone();
var mesh26 = mesh2.clone();

mesh21.rotation.set(0, 0/3*Math.PI, 0);
mesh22.rotation.set(0, 1/3*Math.PI, 0);
mesh23.rotation.set(0, 2/3*Math.PI, 0);
mesh24.rotation.set(0, 3/3*Math.PI, 0);
mesh25.rotation.set(0, 4/3*Math.PI, 0);
mesh26.rotation.set(0, 5/3*Math.PI, 0);

GroupHelix.add( 
	mesh21, 
	mesh22, 
	mesh23, 
	mesh24, 
	mesh25, 
	mesh26 
	);
return GroupHelix;
}


/*
var Helix3 = Helix1( 4, 5, 100, 8.3 );
Helix3.position.set( 0, 0, 0 );
scene.add( Helix3 );

var Helix4 = Helix1( 2, 5, 100, 1.75 );
Helix4.position.set( 0, 51.25, 0 );
scene.add( Helix4 );

var Helix5 = Helix1( 3, 5, 100, 2.4 );
Helix5.position.set( 0, 18.75, 0 );
scene.add( Helix5 );

var Helix6 = Helix1( 4, 5, 100, 4.15 );
Helix6.position.set( 0, -32.5, 0 );
scene.add( Helix6 );
*/
/*
var Helix4 = Helix1( 2, 2.5, 100, 3.4 );
Helix4.position.set( 0, 51.25, 0 );
scene.add( Helix4 );

var Helix6 = Helix1( 4, 5, 100, 6.54 );
Helix6.position.set( 0, -13.75, 0 );
scene.add( Helix6 );
*/

var controls = new THREE.OrbitControls( camera, renderer.domElement );
var animate = function () {
requestAnimationFrame( animate );
renderer.render(scene, camera); 
};

animate();

</script></body></html>