<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Stand</title>
	<script type="text/javascript" src="three.js"></script>
	<script type="text/javascript" src="OrbitControls.js"></script>
	<style>
		body { margin: 0; overflow: hidden;}
		canvas { width: 100%; height: 100%; }
	</style>
</head>
<body>
<script>
var renderer = new THREE.WebGLRenderer();
  renderer.setSize( window.innerWidth, window.innerHeight );
  document.body.appendChild( renderer.domElement );
  var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 10, 10000 );
  camera.position.set( 0, 0, -300 );
  var scene = new THREE.Scene();
  scene.background = new THREE.Color( 0xaaaaaa );
  var controls = new THREE.OrbitControls( camera, renderer.domElement );
  var light0 = new THREE.AmbientLight( 0xffffff, 1 ); 
  scene.add( light0 );
  var light1 = new THREE.PointLight( 0xffffff, 1, 300 ); 
  light1.position.set( 50, 50, 0 );
  scene.add( light1 );

var material = new THREE.MeshPhongMaterial( { color: 0xdddddd } );




var PlatformGT = new THREE.Group();

  var platformF = function () {
    var PlatformArray = [];
    var d = 25;
    var t = 0.6;
    var i = 0;
    PlatformArray[i] = new THREE.Mesh( new THREE.TorusGeometry( d/2, t/2, 8, 64 ), material );
    PlatformArray[i].position.set( 0, 0, 0 ); 
    PlatformArray[i].rotation.set(-Math.PI/2, 0, 0);
    PlatformGT.add( PlatformArray[i] );
    var i = 1;
    PlatformArray[i] = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, d/2, 8 ), material );
    var ro = d/4;
    var fi = 0/3*Math.PI;
    var x = ro * Math.cos(fi);
    var z = ro * Math.sin(fi);
    PlatformArray[i].position.set( x, -t, z ); 
    PlatformArray[i].rotation.set(Math.PI/2, 0, fi+Math.PI/2);
    PlatformGT.add( PlatformArray[i] );
    var i = 2;
    PlatformArray[i] = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, d/2, 8 ), material );
    var ro = d/4;
    var fi = 2/3*Math.PI;
    var x = ro * Math.cos(fi);
    var z = ro * Math.sin(fi);
    PlatformArray[i].position.set( x, -t, z ); 
    PlatformArray[i].rotation.set(Math.PI/2, 0, fi+Math.PI/2);
    PlatformGT.add( PlatformArray[i] );
    var i = 3;
    PlatformArray[i] = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, d/2, 8 ), material );
    var ro = d/4;
    var fi = 4/3*Math.PI;
    var x = ro * Math.cos(fi);
    var z = ro * Math.sin(fi);
    PlatformArray[i].position.set( x, -t, z ); 
    PlatformArray[i].rotation.set(Math.PI/2, 0, fi+Math.PI/2);
    PlatformGT.add( PlatformArray[i] );
    var i = 5;
    PlatformArray[i] = new THREE.Mesh( new THREE.CylinderGeometry( d/2-t/2, d/2-t/2, 0.1, 64 ), material );
    PlatformArray[i].position.set( 0, -t/2+0.05, 0 ); 
    PlatformArray[i].rotation.set(0, 0, 0);
    PlatformGT.add( PlatformArray[i] );
    var i = 6;
    PlatformArray[i] = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, d/2, 8 ), material );
    var ro = d/4;
    var fi = 1/3*Math.PI;
    var x = ro * Math.cos(fi);
    var z = ro * Math.sin(fi);
    PlatformArray[i].position.set( x, -t, z ); 
    PlatformArray[i].rotation.set(Math.PI/2, 0, fi+Math.PI/2);
    PlatformGT.add( PlatformArray[i] );
    var i = 7;
    PlatformArray[i] = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, d/2, 8 ), material );
    var ro = d/4;
    var fi = 3/3*Math.PI;
    var x = ro * Math.cos(fi);
    var z = ro * Math.sin(fi);
    PlatformArray[i].position.set( x, -t, z ); 
    PlatformArray[i].rotation.set(Math.PI/2, 0, fi+Math.PI/2);
    PlatformGT.add( PlatformArray[i] );
    var i = 8;
    PlatformArray[i] = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, d/2, 8 ), material );
    var ro = d/4;
    var fi = 5/3*Math.PI;
    var x = ro * Math.cos(fi);
    var z = ro * Math.sin(fi);
    PlatformArray[i].position.set( x, -t, z ); 
    PlatformArray[i].rotation.set(Math.PI/2, 0, fi+Math.PI/2);
    PlatformGT.add( PlatformArray[i] );
  };
  platformF();
  PlatformGT.position.set( 0, 130/2, 0 );
scene.add(PlatformGT);

var PlatformG0 = new THREE.Group();

  var platformF = function () {
    var PlatformArray = [];
    var d = 20;
    var t = 0.6;
    var i = 0;
    PlatformArray[i] = new THREE.Mesh( new THREE.TorusGeometry( d/2, t/2, 8, 64 ), material );
    PlatformArray[i].position.set( 0, 0, 0 ); 
    PlatformArray[i].rotation.set(-Math.PI/2, 0, 0);
    PlatformG1.add( PlatformArray[i] );
    var i = 1;
    PlatformArray[i] = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, d/2, 8 ), material );
    var ro = d/4;
    var fi = 0/3*Math.PI;
    var x = ro * Math.cos(fi);
    var z = ro * Math.sin(fi);
    PlatformArray[i].position.set( x, -t, z ); 
    PlatformArray[i].rotation.set(Math.PI/2, 0, fi+Math.PI/2);
    PlatformG1.add( PlatformArray[i] );
    var i = 2;
    PlatformArray[i] = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, d/2, 8 ), material );
    var ro = d/4;
    var fi = 2/3*Math.PI;
    var x = ro * Math.cos(fi);
    var z = ro * Math.sin(fi);
    PlatformArray[i].position.set( x, -t, z ); 
    PlatformArray[i].rotation.set(Math.PI/2, 0, fi+Math.PI/2);
    PlatformG1.add( PlatformArray[i] );
    var i = 3;
    PlatformArray[i] = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, d/2, 8 ), material );
    var ro = d/4;
    var fi = 4/3*Math.PI;
    var x = ro * Math.cos(fi);
    var z = ro * Math.sin(fi);
    PlatformArray[i].position.set( x, -t, z ); 
    PlatformArray[i].rotation.set(Math.PI/2, 0, fi+Math.PI/2);
    PlatformG1.add( PlatformArray[i] );
    var i = 4;
    var v = d/2;
    PlatformArray[i] = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, v, 8 ), material );
    PlatformArray[i].position.set( 0, -t-v/2, 0 ); 
    PlatformArray[i].rotation.set(0, 0, 0);
    PlatformG1.add( PlatformArray[i] );
    var i = 5;
    PlatformArray[i] = new THREE.Mesh( new THREE.CylinderGeometry( d/2-t/2, d/2-t/2, 0.1, 64 ), material );
    PlatformArray[i].position.set( 0, -t/2+0.05, 0 ); 
    PlatformArray[i].rotation.set(0, 0, 0);
    PlatformG1.add( PlatformArray[i] );
  };

  var holderF = function () {
    var t = 0.6;
    var radCentrAxe = 5;
    var coordCentrPlatform = 30;
    var radBottomHolder = 30;
    var h1 = 5;
    var h2 = 10;
    var d1 = coordCentrPlatform-radCentrAxe;
    var s1 = (radCentrAxe-2*t)/2-t;
    var alfa = Math.atan(s1/d1);
    var torus = new THREE.Mesh( new THREE.TorusGeometry( t, t/2, 8, 32, 3.1 ), material );
    torus.position.set( 0, 0, 0 ); 
    torus.rotation.set(Math.PI/2, 0, -Math.PI/2);
    PlatformG.add( torus );
    var holder = [];
    var i = 1;
    holder[i] = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, d1, 8, 1 ), material );
    holder[i].position.set( -d1/2, 0, s1 ); 
    holder[i].rotation.set(Math.PI/2, 0, -Math.PI/2-alfa);
    PlatformG.add( holder[i] );
    var i = 2;
    holder[i] = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, d1, 8, 1 ), material );
    holder[i].position.set( -d1/2, 0, -s1 ); 
    holder[i].rotation.set(Math.PI/2, 0, -Math.PI/2+alfa);
    PlatformG.add( holder[i] );
    var i = 3;
    holder[i] = new THREE.Mesh( new THREE.TorusGeometry( radBottomHolder, t/2, 8, 32, 2/7.2*3.14 ), material );
    holder[i].position.set( -7, -34, 0 ); 
    holder[i].rotation.set(0, 0, 1.33);
    PlatformG.add( holder[i] );
  };

  var platformF1 = function (i) {

    PlatformA[i] = PlatformG0.clone();
    var ro = 30;
    var fi = i/3*Math.PI;
    var x = ro * Math.cos(fi);
    var z = ro * Math.sin(fi);
    PlatformA[i].rotation.set( 0, -fi, 0 );
    PlatformA[i].position.set( x, -3, z );
    PlatformG3.add( PlatformA[i] );
  }

  var PlatformG1 = new THREE.Group();
  var PlatformG = new THREE.Group();
  holderF();
  platformF();
  PlatformG.position.set( 0, 0, 0 );
  PlatformG1.position.set( 0, 3, 0 );
  PlatformG0.add( PlatformG );
  PlatformG0.add( PlatformG1 );

  var PlatformA = [];
  var PlatformG3 = new THREE.Group();
  for (var i = 1; i < 7; i++){
    platformF1(i);
  }
scene.add(PlatformG3);


var HelixG = new THREE.Group();

  var helixF = function () {
    var h = 102.5;
    var dt = 8;
    var t = 0.6;

    function CustomSinCurve( scale ) {

    THREE.Curve.call( this );

    this.scale = ( scale === undefined ) ? 1 : scale;

    }

    CustomSinCurve.prototype = Object.create( THREE.Curve.prototype );
    CustomSinCurve.prototype.constructor = CustomSinCurve;

    CustomSinCurve.prototype.getPoint = function ( t ) {
      
      var b = 3/2*a;

      var s = (t - 0.5) * (h/b);
      var tx = a*Math.cos(s);
      var ty = b*s;
      var tz = a*Math.sin(s);

      return new THREE.Vector3( tx, ty, tz ).multiplyScalar( this.scale );

    };

    var HelixArray = [];
    var Helix = new THREE.Group();

    var a = dt/2+t/2;
    var path1 = new CustomSinCurve( 1 );
    var mesh = new THREE.Mesh( new THREE.TubeGeometry( path1, 100, t/2, 8, false ), material );

    for (var i = 1; i < 7; i++){

      HelixArray[i] = mesh.clone();
      HelixArray[i].rotation.set( 0, i/3*Math.PI, 0 );
      Helix.add( HelixArray[i] );
    }

    var a = -(dt/2+1.5*t);
    var path2 = new CustomSinCurve( 1 );
    var mesh = new THREE.Mesh( new THREE.TubeGeometry( path2, 100, t/2, 8, false ), material );

    for (var i = 7; i < 13; i++){

      HelixArray[i] = mesh.clone();
      HelixArray[i].rotation.set( 0, i/3*Math.PI, 0 );
      Helix.add( HelixArray[i] );
    }

    HelixG.add( Helix );


    var TopT = new THREE.Mesh( new THREE.TorusGeometry( dt/2+t/2, t/2, 8, 64 ), material );
    TopT.position.set( 0, h/2, 0 ); 
    TopT.rotation.set(Math.PI/2, 0, 0);
    HelixG.add( TopT );

    var BottomT = new THREE.Mesh( new THREE.TorusGeometry( dt/2+t/2, t/2, 8, 64 ), material );
    BottomT.position.set( 0, -h/2, 0 ); 
    BottomT.rotation.set(Math.PI/2, 0, 0);
    HelixG.add( BottomT );

    var MidT = new THREE.Mesh( new THREE.TorusGeometry( dt/2+t/2+t*2, t/2, 8, 64 ), material );
    MidT.position.set( 0, 10.75, 0 ); 
    MidT.rotation.set(Math.PI/2, 0, 0);
    HelixG.add( MidT );

    var MidT1 = new THREE.Mesh( new THREE.TorusGeometry( dt/2+t/2+t*2, t/2, 8, 64 ), material );
    MidT1.position.set( 0, 0.75, 0 ); 
    MidT1.rotation.set(Math.PI/2, 0, 0);
    HelixG.add( MidT1 );

    var topCT = new THREE.Mesh( new THREE.TorusGeometry( dt/2+t/2+t*2, t/2, 8, 64 ), material );
    topCT.position.set( 0, h/2, 0 ); 
    topCT.rotation.set(Math.PI/2, 0, 0);
    HelixG.add( topCT );

    var topCT1 = new THREE.Mesh( new THREE.TorusGeometry( dt/2+t/2+t*2, t/2, 8, 64 ), material );
    topCT1.position.set( 0, h/2-10, 0 ); 
    topCT1.rotation.set(Math.PI/2, 0, 0);
    HelixG.add( topCT1 );
  }

  helixF();
  HelixG.position.set( 0, -130/2+102.5/2, 0 );
scene.add(HelixG);


var HelixGm = new THREE.Group();

  var helixFm = function () {
    var h = 27;
    var dt = 3.5;
    var t = 0.6;
    /*
  function CustomSinCurve( scale ) {

    THREE.Curve.call( this );

    this.scale = ( scale === undefined ) ? 1 : scale;

    }

    CustomSinCurve.prototype = Object.create( THREE.Curve.prototype );
    CustomSinCurve.prototype.constructor = CustomSinCurve;

    CustomSinCurve.prototype.getPoint = function ( t ) {
      
      var b = 3/2*a;

      var s = (t - 0.5) * (h/b);
      var tx = a*Math.cos(s);
      var ty = b*s;
      var tz = a*Math.sin(s);

      return new THREE.Vector3( tx, ty, tz ).multiplyScalar( this.scale );

    };

    var HelixArray = [];
    var Helix = new THREE.Group();

    var a = dt/2+t/2;
    var path1 = new CustomSinCurve( 1 );
    var mesh = new THREE.Mesh( new THREE.TubeGeometry( path1, 100, t/2, 8, false ), material );

    for (var i = 1; i < 7; i=i+2){

      HelixArray[i] = mesh.clone();
      HelixArray[i].rotation.set( 0, i/3*Math.PI, 0 );
      Helix.add( HelixArray[i] );
    }

    var a = -(dt/2+1.5*t);
    var path2 = new CustomSinCurve( 1 );
    var mesh = new THREE.Mesh( new THREE.TubeGeometry( path2, 100, t/2, 8, false ), material );

    for (var i = 7; i < 13; i=i+2){

      HelixArray[i] = mesh.clone();
      HelixArray[i].rotation.set( 0, i/3*Math.PI, 0 );
      Helix.add( HelixArray[i] );
    }

    HelixGm.add( Helix );
  */
  /*
    var TopT = new THREE.Mesh( new THREE.TorusGeometry( dt/2+t/2, t/2, 8, 64 ), material );
    TopT.position.set( 0, h/2, 0 ); 
    TopT.rotation.set(Math.PI/2, 0, 0);
    HelixGm.add( TopT );

    var BottomT = new THREE.Mesh( new THREE.TorusGeometry( dt/2+t/2, t/2, 8, 64 ), material );
    BottomT.position.set( 0, -h/2, 0 ); 
    BottomT.rotation.set(Math.PI/2, 0, 0);
    HelixGm.add( BottomT );
  */

          var PlatformArray = [];
          //-h-t
          var hh = 65-27.5+0.6;
          var d = 9;
          var i = 1;
          PlatformArray[i] = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, d, 8 ), material );
          var ro = d/4;
          var fi = 0/3*Math.PI;
          var x = ro * Math.cos(fi);
          var z = ro * Math.sin(fi);
          PlatformArray[i].position.set( 0, hh, 0 ); 
          PlatformArray[i].rotation.set(Math.PI/2, 0, fi+Math.PI/2);
          HelixGm.add( PlatformArray[i] );
          var i = 2;
          PlatformArray[i] = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, d, 8 ), material );
          var ro = d/4;
          var fi = 2/3*Math.PI;
          var x = ro * Math.cos(fi);
          var z = ro * Math.sin(fi);
          PlatformArray[i].position.set( 0, hh, 0 ); 
          PlatformArray[i].rotation.set(Math.PI/2, 0, fi+Math.PI/2);
          HelixGm.add( PlatformArray[i] );
          var i = 3;
          PlatformArray[i] = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, d, 8 ), material );
          var ro = d/4;
          var fi = 4/3*Math.PI;
          var x = ro * Math.cos(fi);
          var z = ro * Math.sin(fi);
          PlatformArray[i].position.set( 0, hh, 0 ); 
          PlatformArray[i].rotation.set(Math.PI/2, 0, fi+Math.PI/2);
          HelixGm.add( PlatformArray[i] );

  }

  helixFm();
  //HelixGm.position.set( 0, 52, 0 );
  HelixGm.position.set( 0, 0, 0 );
scene.add(HelixGm);


var M1 = new THREE.Mesh( new THREE.TorusGeometry( 5.6/2, 0.3, 8, 16 ), material );
  M1.rotation.set(Math.PI/2, 0, 0);
  M1.position.set( 0, 65-1.2, 0 );
  var M2 = new THREE.Mesh( new THREE.TorusGeometry( 5.6/2, 0.3, 8, 16 ), material );
  M2.rotation.set(Math.PI/2, 0, 0);
  M2.position.set( 0, 65-27.5+1.2, 0 );

    var C1= [];
    for (var i = 1; i < 7; i++){
    C1[i] = new THREE.Mesh( new THREE.CylinderGeometry( 0.3, 0.3, 25.1, 8 ), material );
    var fi = i/3*Math.PI;
    var x = 5.6/2 * Math.cos(fi);
    var z = 5.6/2 * Math.sin(fi);
    C1[i].position.set( x, 51.25, z );
    scene.add( C1[i] );
    };

scene.add(M1,M2);


var FootingG = new THREE.Group();
  var footing = function () {
    var PlatformArray = [];
    var d = 70;
    var t = 0.6;
    var i = 0;
    PlatformArray[i] = new THREE.Mesh( new THREE.TorusGeometry( d/2, t/2, 8, 64 ), material );
    PlatformArray[i].position.set( 0, 0, 0 ); 
    PlatformArray[i].rotation.set(-Math.PI/2, 0, 0);
    FootingG.add( PlatformArray[i] );
    var i = 1;
    PlatformArray[i] = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, d, 8 ), material );
    var ro = d/4;
    var fi = 0/3*Math.PI;
    var x = ro * Math.cos(fi);
    var z = ro * Math.sin(fi);
    PlatformArray[i].position.set( 0, t, 0 ); 
    PlatformArray[i].rotation.set(Math.PI/2, 0, fi+Math.PI/2);
    FootingG.add( PlatformArray[i] );
    var i = 2;
    PlatformArray[i] = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, d, 8 ), material );
    var ro = d/4;
    var fi = 2/3*Math.PI;
    var x = ro * Math.cos(fi);
    var z = ro * Math.sin(fi);
    PlatformArray[i].position.set( 0, t, 0 ); 
    PlatformArray[i].rotation.set(Math.PI/2, 0, fi+Math.PI/2);
    FootingG.add( PlatformArray[i] );
    var i = 3;
    PlatformArray[i] = new THREE.Mesh( new THREE.CylinderGeometry( t/2, t/2, d, 8 ), material );
    var ro = d/4;
    var fi = 4/3*Math.PI;
    var x = ro * Math.cos(fi);
    var z = ro * Math.sin(fi);
    PlatformArray[i].position.set( 0, t, 0 ); 
    PlatformArray[i].rotation.set(Math.PI/2, 0, fi+Math.PI/2);
    FootingG.add( PlatformArray[i] );
    var i = 4;
    PlatformArray[i] = new THREE.Mesh( new THREE.TorusGeometry( 20, t/2, 8, 64 ), material );
    PlatformArray[i].position.set( 0, 0, 0 ); 
    PlatformArray[i].rotation.set(-Math.PI/2, 0, 0);
    FootingG.add( PlatformArray[i] );
    var i = 5;
    PlatformArray[i] = new THREE.Mesh( new THREE.TorusGeometry( 5, t/2, 8, 64 ), material );
    PlatformArray[i].position.set( 0, 0, 0 ); 
    PlatformArray[i].rotation.set(-Math.PI/2, 0, 0);
    FootingG.add( PlatformArray[i] );
  }
  footing();
  FootingG.position.set( 0, -65+0.3-0.6*2, 0 );
scene.add(FootingG);



var planeP = new THREE.Mesh( new THREE.PlaneGeometry( 1000, 1000 ), new THREE.MeshPhongMaterial( {color: 0x555555} ) );
  planeP.position.set( 0, -65-0.6*2, 0 ); planeP.rotation.set(-Math.PI/2, 0, 0);
  scene.add( planeP );

var Box = new THREE.Mesh( new THREE.BoxGeometry( 20, 1, 20 ), new THREE.MeshPhongMaterial( {color: 0x777777} ) );
  Box.position.set( 0, 130/2, 0 ); //planeP.rotation.set(-Math.PI/2, 0, 0);
  //scene.add( Box );

var animate = function () {
  requestAnimationFrame( animate );
  renderer.render(scene, camera); 
};
animate();

</script></body>
</html>